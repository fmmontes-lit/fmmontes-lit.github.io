<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Newton's Cradle — HTML5 Canvas</title>
    <style>
      .wrap {
        display: flex;
        flex-direction: column;
        height: 100%;
        gap: 8px;
        align-items: center;
        justify-content: center;
      }
      canvas {
        background: linear-gradient(#fff, #eef2ff);
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(20, 30, 70, 0.08);
      }
      .controls {
        font-size: 13px;
        color: #333;
        text-align: center;
      }
      .hint {
        opacity: 0.8;
        font-size: 12px;
        margin-top: 6px;
      }
    </style>
  </head>
  <body>
    <h1>LIT Moto - Conservation of Momentum</h1>
    <div class="wrap">
      <canvas id="c"></canvas>
      <div class="controls">
        <strong>Newton's Cradle</strong> — drag any ball and release.
        <span class="hint"
          >All balls have equal mass, length, and damping.</span
        >
      </div>
    </div>

    <script>
      (() => {
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");

        // --- Parameters (single "kind" of ball)
        const N = 5; // number of balls
        const L = 170; // pendulum length in px
        const r = 18; // ball radius in px
        const spacing = r * 2 + 2; // horizontal spacing between pivot points
        const originY = 80; // pivot y
        const g = 980; // gravity (px/s^2) — scaled for pixels
        const damping = 0.9995; // gentle damping per frame
        const timeScale = 1.0; // speed multiplier

        // State arrays
        const theta = new Array(N).fill(0); // angle from vertical (radians)
        const thetaDot = new Array(N).fill(0); // angular velocity (rad/s)
        const pivotX = new Array(N).fill(0); // pivot x positions (px)

        // Canvas sizing
        function resize() {
          canvas.width = Math.min(window.innerWidth - 40, 960);
          canvas.height = Math.min(window.innerHeight - 120, 520);
          // center cradle horizontally
          const totalWidth = (N - 1) * spacing;
          const startX = (canvas.width - totalWidth) / 2;
          for (let i = 0; i < N; i++) pivotX[i] = startX + i * spacing;
        }
        window.addEventListener("resize", resize);
        resize();

        // initial small offset on leftmost ball for visual
        theta[0] = -Math.PI / 6; // start leftmost ball pulled out slightly

        // integration parameters
        let lastTime = performance.now();

        // mouse interaction
        let dragging = false;
        let dragIndex = -1;
        function getMousePos(evt) {
          const rect = canvas.getBoundingClientRect();
          return {
            x: (evt.clientX - rect.left) * (canvas.width / rect.width),
            y: (evt.clientY - rect.top) * (canvas.height / rect.height),
          };
        }

        canvas.addEventListener("pointerdown", (e) => {
          const m = getMousePos(e);
          // check if near any ball
          for (let i = 0; i < N; i++) {
            const bx = pivotX[i] + L * Math.sin(theta[i]);
            const by = originY + L * Math.cos(theta[i]);
            const dx = m.x - bx,
              dy = m.y - by;
            if (dx * dx + dy * dy <= (r + 6) * (r + 6)) {
              dragging = true;
              dragIndex = i;
              thetaDot[i] = 0; // stop movement while dragging
              canvas.setPointerCapture(e.pointerId);
              break;
            }
          }
        });

        canvas.addEventListener("pointermove", (e) => {
          if (!dragging) return;
          const m = getMousePos(e);
          const i = dragIndex;
          // compute new angle from pivot to mouse
          const dx = m.x - pivotX[i];
          const dy = m.y - originY;
          // angle relative to vertical: atan2(x, y)
          theta[i] = Math.atan2(dx, dy);
          thetaDot[i] = 0;
        });

        canvas.addEventListener("pointerup", (e) => {
          if (!dragging) return;
          dragging = false;
          dragIndex = -1;
          try {
            canvas.releasePointerCapture(e.pointerId);
          } catch (_) {}
        });
        canvas.addEventListener("pointercancel", () => {
          dragging = false;
          dragIndex = -1;
        });

        // main loop
        function step(now) {
          const dt = Math.min(0.033, (now - lastTime) / 1000) * timeScale; // clamp to avoid large jumps
          lastTime = now;

          updatePhysics(dt);
          render();

          requestAnimationFrame(step);
        }

        // Physics:
        // - Each ball: theta'' = -(g/L) * sin(theta) (simple pendulum)
        // - integrate with semi-implicit Euler
        // - damping applied to angular velocity
        // - collisions: for each adjacent pair, if distance < 2r and relative x-velocity is closing,
        //   exchange their horizontal velocities (approximates elastic collision for equal masses).
        function updatePhysics(dt) {
          // integrate each pendulum
          for (let i = 0; i < N; i++) {
            if (dragging && i === dragIndex) continue; // skip integrating dragged ball
            // angular acceleration
            const a = -(g / L) * Math.sin(theta[i]);
            thetaDot[i] += a * dt;
            thetaDot[i] *= Math.pow(damping, dt * 60); // frame-rate independent-ish damping
            theta[i] += thetaDot[i] * dt;
          }

          // collision detection/resolution between adjacent balls
          // compute horizontal positions and velocities for each ball
          const x = new Array(N),
            y = new Array(N),
            vx = new Array(N),
            vy = new Array(N);
          for (let i = 0; i < N; i++) {
            x[i] = pivotX[i] + L * Math.sin(theta[i]);
            y[i] = originY + L * Math.cos(theta[i]);
            // dx/dt = L * cos(theta) * thetaDot
            vx[i] = L * Math.cos(theta[i]) * thetaDot[i];
            vy[i] = -L * Math.sin(theta[i]) * thetaDot[i]; // not used for collision but computed for completeness
          }

          // check neighbors only (line of touching balls)
          for (let i = 0; i < N - 1; i++) {
            const dx = x[i + 1] - x[i];
            const dy = y[i + 1] - y[i];
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 2 * r - 0.01) {
              // relative closing velocity along the line connecting centers
              const nx = dx / (dist || 1);
              const ny = dy / (dist || 1);
              const relV = (vx[i + 1] - vx[i]) * nx + (vy[i + 1] - vy[i]) * ny;

              // Only resolve if they are moving towards each other
              if (relV < 0) {
                // For equal masses, elastic one-dimensional collision => swap velocity components along collision normal
                // We'll swap horizontal components projected properly.
                // Compute each ball's velocity along normal:
                const vi_n = vx[i] * nx + vy[i] * ny;
                const vj_n = vx[i + 1] * nx + vy[i + 1] * ny;

                // swap normal components
                const new_vi_n = vj_n;
                const new_vj_n = vi_n;

                // compute tangential components (remaining part) - keep them unchanged
                const vi_t_x = vx[i] - vi_n * nx;
                const vi_t_y = vy[i] - vi_n * ny;
                const vj_t_x = vx[i + 1] - vj_n * nx;
                const vj_t_y = vy[i + 1] - vj_n * ny;

                // new total velocities (x,y)
                const vi_new_x = vi_t_x + new_vi_n * nx;
                const vi_new_y = vi_t_y + new_vi_n * ny;
                const vj_new_x = vj_t_x + new_vj_n * nx;
                const vj_new_y = vj_t_y + new_vj_n * ny;

                // convert back to angular velocities:
                // thetaDot = vx / (L * cos(theta))  -- solve for thetaDot from horizontal component
                // safeguard: if cos(theta) ~ 0 use fallback division by 1
                const cosi =
                  Math.abs(Math.cos(theta[i])) < 0.0001
                    ? 1
                    : Math.cos(theta[i]);
                const cosj =
                  Math.abs(Math.cos(theta[i + 1])) < 0.0001
                    ? 1
                    : Math.cos(theta[i + 1]);

                thetaDot[i] = vi_new_x / (L * cosi);
                thetaDot[i + 1] = vj_new_x / (L * cosj);

                // small positional correction to avoid sticking: push them slightly apart along normal
                const overlap = 2 * r - dist;
                if (overlap > 0) {
                  const correction = 0.5 * overlap + 0.01;
                  // convert correction to small angle adjustment by moving theta slightly along sign of nx
                  // approximate deltaX ~ L*cos(theta)*dtheta -> dtheta ~ deltaX / (L*cos)
                  const dtheta_i = -(correction * nx) / (L * cosi);
                  const dtheta_j = (correction * nx) / (L * cosj);
                  if (!(dragging && i === dragIndex)) theta[i] += dtheta_i;
                  if (!(dragging && i + 1 === dragIndex))
                    theta[i + 1] += dtheta_j;
                }
              }
            }
          }
        }

        // rendering
        function render() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // draw top bar (support)
          ctx.fillStyle = "#2b3a67";
          ctx.fillRect(0, 0, canvas.width, 6);
          // draw pivots & strings & balls
          for (let i = 0; i < N; i++) {
            const px = pivotX[i];
            const py = originY;

            const bx = px + L * Math.sin(theta[i]);
            const by = py + L * Math.cos(theta[i]);

            // string
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(bx, by);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#3338";
            ctx.stroke();

            // pivot marker
            ctx.beginPath();
            ctx.arc(px, py, 4, 0, Math.PI * 2);
            ctx.fillStyle = "#222";
            ctx.fill();

            // ball (simple shading)
            const grd = ctx.createLinearGradient(
              bx - r,
              by - r,
              bx + r,
              by + r
            );
            grd.addColorStop(0, "#ffffff");
            grd.addColorStop(0.4, "#dfe9ff");
            grd.addColorStop(1, "#b0c4ff");
            ctx.beginPath();
            ctx.arc(bx, by, r, 0, Math.PI * 2);
            ctx.fillStyle = grd;
            ctx.fill();

            // outline
            ctx.beginPath();
            ctx.arc(bx, by, r, 0, Math.PI * 2);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#345";
            ctx.stroke();

            // subtle shadow
            ctx.beginPath();
            ctx.ellipse(bx, by + r + 6, r * 0.9, r * 0.28, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(30,40,70,0.06)";
            ctx.fill();
          }
        }

        // kick off animation
        requestAnimationFrame(step);
      })();
    </script>
  </body>
</html>
